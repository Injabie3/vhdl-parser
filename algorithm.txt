# incomplete
- complete

findAndSetTokenDetails
	 - Examine stringRep in the token, and make everything in the string lowercase via a local copy
	 - If the token is a keyword, trip _isKeyword bool.
		- Find first of ,<>=:\"'.:+-/*&|;#()0123456789 (aka delimiters and alphanumerals), and don't continue checking for keyword if -1 is not produced.
		- Run through a loop to compare with an array that has the keywords all in lowercase.
	 - Categorize token into one of the following:
		- comment bodies
			- Make sure previous token exists.
			- check previous token to see if it contains "--"
			- check if the current token is not a \n or \r
			- If both statements above are true, then token is a comment body
		- operators
			- Compare local stringRep of token to operators array to see if there is a match.
				- If matched, then categorize as operator.
		- identifiers
			- Check if first character is a letter.
			- check to see that there are no illegal ID characters (eg. delimiters)
			- If above is all okay, categorize as identifier.
			- Check previous token for "signal" or "variable"
				- If true, then check the token after the next (aka the one after :)
				- Take that token as the type.
				- Check the token after the type.
					<type> ( # downto/to # )
					- If that token is (, take next token # and convert to int, and store as "starting value"
					- skip downto/to token, and take next token # and convert to int, and store as "end value"
					- http://stackoverflow.com/questions/194465/how-to-parse-a-string-to-an-int-in-c for into on string to int conversion
					- take the difference of the absolute value of the two, and add 1 to it.
					- This is the width of the token. Store accordingly
			# If the previous token was a ",", check previous tokens (provided they are not NULL) until you hit a \n to see if you can find "signal" or "variable".
				# If true, then find the token after : that appears after the current token
				# Take that token as the type.
				# Check the token after the type.
					<type> ( # downto/to # )
					# If that token is (, take next token # and convert to int, and store as "starting value"
					# skip downto/to token, and take next token # and convert to int, and store as "end value"
					# http://stackoverflow.com/questions/194465/how-to-parse-a-string-to-an-int-in-c for into on string to int conversion
					# take the difference of the absolute value of the two, and add 1 to it.
					# This is the width of the token. Store accordingly
			- If above is not satisfied, check all previous tokens to see if there is another identifier with same name, and copy its contents if needed.
		- literals
			- check for two instances of '' or "", or if token contains numerals only, or true false.
			- If true, then categorize as literal.
			- If first character is ', then type is std_logic. No width
			- If first character is ", then type is std_logic_vector. Width = difference between " positions
			- if first character is numeral, then type is integer. No width
			- Check if first character is box - then type is std_logic_vector
				- Find length between ""
				- multiply that length accordingly depending on binary/octal/hex and that is width
		- others
			- last case, take care of everything else.
			
			
			
findAllConditionalExpressions
	- While the pointer to the current token is not NULL:
		- If "if", "elsif", "else", or "when" is found, toggle conditional flag.
		- Else if "end" is found, check next token to see if it's an "if" and handle accordingly.
		- Else if conditional flag is true, make a copy of the token, and append to new TokenList.
		- Go to next token
	- Return pointer to new TokenList.
			
			
			
			
Code below for operators and keywords:
			
string operators[28] = {"**","abs","not","*","/","mod","rem","+","-","&","sll","srl","sla","sra","rol","ror","=","/=","<","<=",">",">=","and","or","nand","nor","xor","xnor"};

string keywords[97]= {"abs","access","after","alias","all","and","architecture","array","assert","attribute","begin","block","body","buffer","bus","case","component","configuration","constant","disconnect","downto","else","elsif","end","entity","exit","file","for","function","generate","generic","group","guarded","if","impure","in","inertial","inout","is","label","library","linkage","literal","loop","map","mod","nand","new","next","nor","not","null","of","on","open","or","others","out","package","port","postponed","procedure","process","pure","range","record","register","reject","rem","report","return","rol","ror","select","severity","signal","shared","sla","sll","sra","srl","subtype","then","to","transport","type","unaffected","units","until","use","variable","wait","when","while","with","xnor","xor"};
